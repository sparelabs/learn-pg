import type { Exercise } from '@learn-pg/shared';

export const exercises: Exercise[] = [
  {
    id: 'current-wal-lsn',
    lessonId: '',
    type: 'sql-query',
    title: 'Check Current WAL Position',
    prompt: 'Query the current WAL write position using pg_current_wal_lsn(). This returns the Log Sequence Number — a pointer to the current position in the WAL stream.',
    setupSql: '',
    hints: [
      'SELECT pg_current_wal_lsn()',
      'The result is in hex format like 0/1A3B4C0',
      'This value increases monotonically with every change'
    ],
    explanation: 'pg_current_wal_lsn() returns the current write position in the WAL stream. Every change to the database (INSERT, UPDATE, DELETE, DDL) advances this position. The LSN format is segment/offset, displayed as a hexadecimal pair. This is the foundation for monitoring replication lag and tracking WAL generation.',
    validation: {
      strategy: 'result-match',
      rules: {
        strategy: 'result-match',
        rules: {
          rowCount: { exact: 1 },
          columns: {
            required: ['pg_current_wal_lsn']
          }
        }
      }
    },
    order: 1,
    difficulty: 1
  },
  {
    id: 'wal-level',
    lessonId: '',
    type: 'sql-query',
    title: 'Check WAL Level',
    prompt: 'Check the current WAL level setting. This determines how much information PostgreSQL records in WAL: minimal (crash recovery only), replica (streaming replication), or logical (logical replication/CDC).',
    setupSql: '',
    hints: [
      'Use SHOW wal_level',
      'Common values: minimal, replica, logical',
      'Higher levels record more data and generate more WAL'
    ],
    explanation: 'wal_level controls the amount of information written to WAL. "replica" (the default) records enough for physical streaming replication. "logical" adds information needed for logical replication and Change Data Capture. Higher levels generate more WAL but enable more features.',
    validation: {
      strategy: 'result-match',
      rules: {
        strategy: 'result-match',
        rules: {
          rowCount: { exact: 1 }
        }
      }
    },
    order: 2,
    difficulty: 1
  },
  {
    id: 'wal-stats',
    lessonId: '',
    type: 'sql-query',
    title: 'View WAL Statistics',
    prompt: 'Query the pg_stat_wal view to see WAL generation statistics. Run: SELECT wal_records, wal_bytes, wal_write, wal_sync FROM pg_stat_wal.',
    setupSql: '',
    hints: [
      'SELECT wal_records, wal_bytes, wal_write, wal_sync FROM pg_stat_wal',
      'wal_records = total WAL records generated',
      'wal_bytes = total WAL data in bytes'
    ],
    explanation: 'pg_stat_wal (PostgreSQL 14+) provides cumulative WAL statistics since server start. wal_records and wal_bytes show total WAL volume generated. wal_write and wal_sync show disk write and fsync operations. High wal_sync values relative to wal_write indicate synchronous commit overhead.',
    validation: {
      strategy: 'result-match',
      rules: {
        strategy: 'result-match',
        rules: {
          rowCount: { exact: 1 },
          columns: {
            required: ['wal_records', 'wal_bytes']
          }
        }
      }
    },
    order: 3,
    difficulty: 2
  },
  {
    id: 'wal-generation',
    lessonId: '',
    type: 'sql-query',
    title: 'Observe WAL Generation from Inserts',
    prompt: 'Observe how much WAL is generated by inserting data. First get the current LSN, insert 10,000 rows, then get the LSN again and calculate the difference. Run: SELECT pg_current_wal_lsn() AS before_lsn; then insert rows into wal_test, then SELECT pg_current_wal_lsn() AS after_lsn.',
    setupSql: `
      DROP TABLE IF EXISTS wal_test;
      CREATE TABLE wal_test (
        id INTEGER,
        value TEXT
      );
    `,
    hints: [
      'SELECT pg_current_wal_lsn() AS before_lsn',
      'INSERT INTO wal_test SELECT i, \'data_\' || i FROM generate_series(1, 10000) i',
      'SELECT pg_current_wal_lsn() AS after_lsn',
      'You can calculate the difference with pg_wal_lsn_diff()'
    ],
    explanation: 'Every INSERT generates WAL records. For 10,000 rows, you\'ll see the LSN advance by several megabytes. The actual WAL size depends on row width — wider rows generate more WAL. Understanding WAL generation helps predict replication lag and storage needs.',
    validation: {
      strategy: 'result-match',
      rules: {
        strategy: 'result-match',
        rules: {
          rowCount: { exact: 1 }
        }
      }
    },
    order: 4,
    difficulty: 2
  }
];
